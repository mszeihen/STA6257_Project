<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.361">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Untitled</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="_Introduction_section_files/libs/clipboard/clipboard.min.js"></script>
<script src="_Introduction_section_files/libs/quarto-html/quarto.js"></script>
<script src="_Introduction_section_files/libs/quarto-html/popper.min.js"></script>
<script src="_Introduction_section_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="_Introduction_section_files/libs/quarto-html/anchor.min.js"></script>
<link href="_Introduction_section_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="_Introduction_section_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="_Introduction_section_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="_Introduction_section_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="_Introduction_section_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Untitled</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  

</header>

<p>In this study, we employ Bayesian Networks to predict whether individuals earn more than $50,000 annually based on demographic and employment-related attributes from the Adult Income Dataset. We use Bayesian Networks to model probabilistic dependencies among variables, providing a structured approach to understanding income factors. The goal is to develop a predictive model that identifies key factors influencing these income levels, offering a methodical approach to understanding socioeconomic dynamics.</p>
<section id="i-1.-what-is-a-bayesian-network" class="level2">
<h2 class="anchored" data-anchor-id="i-1.-what-is-a-bayesian-network">I-1. What is a “Bayesian Network”?</h2>
<p>A Bayesian network, a belief network, or a probabilistic graphical model represents a set of variables and their conditional dependencies via a Directed Acyclic Graph (DAG). <span class="citation" data-cites="pearl1986fusion">[@pearl1986fusion]</span> EEach node in the graph represents a random variable, and the edges between the nodes represent probabilistic dependencies among these variables. Bayes’ theorem is a fundamental concept used in this network. Bayes’ theorem describes the probability of an event based on prior knowledge of conditions that might be related to the event. The formula for Bayes’ theorem is <span class="math display">\[
P(A \mid B) = \frac{P(B \mid A) \cdot P(A)}{P(B)}
\]</span></p>
<p>This equation describes how to update the probability of a hypothesis <span class="math inline">\((A)\)</span> given new evidence <span class="math inline">\((B)\)</span>. Here, <span class="math inline">\(P(A \mid B)\)</span> is the posterior probability (the probability of <span class="math inline">\((A)\)</span> given <span class="math inline">\((B)\)</span>), <span class="math inline">\(P(B \mid A)\)</span> is the likelihood (the probability of <span class="math inline">\((B)\)</span> given <span class="math inline">\((A)\)</span>, <span class="math inline">\(P(A)\)</span> is the prior probability (the initial probability of <span class="math inline">\((A)\)</span>, and <span class="math inline">\(P(B)\)</span> is the marginal probability (the total probability of <span class="math inline">\((B)\)</span>. The theorem’s formulation is crucial for understanding how evidence impacts our belief in a hypothesis by combining prior knowledge with new evidence to provide an updated probability <span class="citation" data-cites="Gelman2022">[@Gelman2022]</span></p>
</section>
<section id="i-2.-what-is-the-bayesian-theorem" class="level2">
<h2 class="anchored" data-anchor-id="i-2.-what-is-the-bayesian-theorem">I-2. What is the Bayesian Theorem?</h2>
<p>A simple Bayesian network can be visualized as a directed acyclic graph (DAG) with nodes representing random variables and directed edges representing conditional dependencies between these variables. <span class="citation" data-cites="koller2009probabilistic">[@koller2009probabilistic]</span></p>
<figure style="text-align: center;" class="figure">
<p><img src="img/Simple_Bayesian_Student.png" alt="Alt text" style="display: block; margin: 0 auto; width: 50%;" class="figure-img"></p>
<figcaption class="figure-caption">
Figure 1: Simple Bayesian Network
</figcaption>
</figure>
<p>Bayesian networks leverage Bayes’ theorem to update the probabilities of various hypotheses given new Evidence, allowing for probabilistic reasoning and decision-making under uncertainty. The process involves defining the network structure and conditional probabilities, calculating joint and marginal probabilities, and applying Bayes’ theorem to infer the posterior probabilities. <span class="citation" data-cites="koller2009probabilistic">[@koller2009probabilistic]</span></p>
<p>An illustrative example of Bayes’ Theorem in action is the Bertrand box paradox. This paradox involves three boxes, one with two gold coins, one with two silver coins, and one with one gold and one silver coin. If a coin is randomly drawn from a box and it turns out to be gold, Bayes’ Theorem helps calculate the probability that the box with one gold and one silver coin was chosen. The theorem updates the probability based on the new evidence (the gold coin drawn) and the prior probability of each box being chosen. <span class="citation" data-cites="Flusser1984">[@Flusser1984]</span></p>
<p>This paradox is often used to describe the Bayes’ Theorem. But instead of having two draws with outcomes being gold and silver, it’s the TV game show where a presenter make choose a player one of the three doors. Behind two of them are goats and behind one of them there is a car. Once the player made his choice, the presenter of the show will open one door where there is a goat and ask him if he wants to change door. By using the Bayes’ Theorem on this case, the result gives that the player has more chance to get the car by changing door. The whole principle of the Bayes’ equation is used in the Bayesian Networks when taking a look at the conditional probability tables.</p>
<section id="i-3.-what-are-the-advantages-of-using-bayesian-networks" class="level3">
<h3 class="anchored" data-anchor-id="i-3.-what-are-the-advantages-of-using-bayesian-networks">I-3. What are the advantages of using Bayesian Networks</h3>
<p>Data analysis offers a variety of tools like rule-based systems, decision trees, and artificial neural networks, along with techniques such as density estimation, classification, regression, and clustering. <span class="citation" data-cites="heckerman1995tutorial">[@heckerman1995tutorial]</span> What unique advantages do Bayesian networks and Bayesian methods bring to the table in this landscape?</p>
<p>In the paper “A Bayesian Method for the Induction of Probabilistic Networks from Data”<span class="citation" data-cites="cooper1992bayesian">[@cooper1992bayesian]</span>, here are some of the advantages mentioned using Bayesian Networks:</p>
<p><strong>Handling Incomplete Data:</strong></p>
<p>Bayesian networks facilitate learning causal relationships, which are crucial for understanding complex systems and making predictions under interventions. For example, determining if increasing advertisement exposure causes higher product sales can be analyzed using Bayesian networks, even without direct experimental data.</p>
<p><strong>Learning Causal Relationships:</strong></p>
<p>Bayesian networks facilitate learning causal relationships, which are crucial for understanding complex systems and making predictions under interventions. For example, determining if increasing advertisement exposure causes higher product sales can be analyzed using Bayesian networks, even without direct experimental data.</p>
<p><strong>Combining Domain Knowledge and Data:</strong></p>
<p>Bayesian networks seamlessly integrate domain knowledge (prior knowledge) with data. This domain knowledge is particularly beneficial when data is limited or costly. Their causal semantics make it straightforward to incorporate prior knowledge about causal relationships, enhancing the accuracy and reliability of predictions.</p>
<p><strong>Avoiding Overfitting:</strong></p>
<p>Bayesian networks provide an efficient approach to prevent overfitting. They achieve this by “smoothing” models using all available data during training, eliminating the need to reserve data for testing purposes. Using all data ensures that models generalize well to new data and avoid capturing noise or spurious patterns from the training data.</p>
</section>
<section id="i-4.-applications-of-bayesian-networks" class="level3">
<h3 class="anchored" data-anchor-id="i-4.-applications-of-bayesian-networks">I-4. Applications of Bayesian Networks</h3>
<p>We widely apply Bayesian networks across diverse fields due to their capabilities in modeling probabilistic relationships. A few examples are - In healthcare, they are used to examine how psychiatric, demographic, and socioeconomic variables interrelate <span class="citation" data-cites="bilek2018investigation">[@bilek2018investigation]</span>; in supply chain management, they can play a crucial role in assessing risks, evaluating resilience and analyzing ripple effects - aiding in making informed decisions among uncertainties<span class="citation" data-cites="hosseini2020bayesian">[@hosseini2020bayesian]</span>. In political studies, they can assist in predicting online participation patterns by analyzing user interactions and engagement metrics <span class="citation" data-cites="kopacheva2021predicting">[@kopacheva2021predicting]</span>. Bayesian networks provide dynamic modeling, learning, and inference - enabling an understanding of evolving systems over time in various applications <span class="citation" data-cites="shiguihara2021dynamic">[@shiguihara2021dynamic]</span>. All these example applications underscore the utility of Bayesian networks in addressing complex probabilistic challenges across different domains and further their practical usefulness.</p>
</section>
<section id="i-5.-components-of-bayesian-networks" class="level3">
<h3 class="anchored" data-anchor-id="i-5.-components-of-bayesian-networks">I-5. Components of Bayesian Networks</h3>
<p>Bayesian networks are sophisticated models that represent probabilistic relationships among variables using a directed acyclic graph (DAG). The primary components of Bayesian networks include nodes, edges, and conditional probability distributions, each playing a crucial role in defining the network’s structure and behavior.</p>
<p>Nodes in a Bayesian network represent random variables. The classification of these variables falls into several categories based on their roles within the network. Parent nodes have outgoing edges to other nodes, signifying causal or influential relationships. On the other hand, child nodes are the recipients of these edges, representing variables influenced or caused by the parent nodes. Additionally, evidence nodes are those for which we have observed data; using these observations can update the beliefs about other variables in the network. Query nodes are the variables of interest for which we seek to compute posterior probabilities given the Evidence. This categorization helps organize and understand the information flow within the network <span class="citation" data-cites="pearl1986fusion">[@pearl1986fusion]</span>.</p>
<p>Edges in a Bayesian network are directed and represent probabilistic dependencies between the nodes. An edge from node A to node B indicates that A is a parent of B, and the probability distribution of B is conditionally dependent on the state of A. This directional relationship is a critical aspect of Bayesian networks, as it encodes the causal assumptions and the flow of influence among the variables es <span class="citation" data-cites="pearl1986fusion">[@pearl1986fusion]</span>.</p>
<p>The structure of a Bayesian network is a directed acyclic graph (DAG). A DAG is a directed graph containing no cycles. It is impossible to start at any node and follow a consistent direction along the edges to return to the starting node. This acyclic property is fundamental because it ensures no infinite loop in the probabilistic dependencies, allowing for coherent probabilistic inferences. The DAG structure facilitates the decomposition of the joint probability distribution of the variables into a product of conditional probability distributions, greatly simplifying the representation and computation of complex probabilistic models<span class="citation" data-cites="koller2009probabilistic">[@koller2009probabilistic]</span>.</p>
<p>Probabilistic inferences in Bayesian networks involve computing the posterior probabilities of query nodes given the evidence nodes. This process uses the network’s structure and the conditional probability distributions to propagate information and update beliefs. One of the key concepts in performing these inferences is conditional independence, which allows for significant computational efficiency. Conditional independence means that a variable is independent of another variable given a set of other variables, reducing the number of direct dependencies that need to be considered <span class="citation" data-cites="koller2009probabilistic">[@koller2009probabilistic]</span>.</p>
<p>Lastly, the conditional probability tree represents the conditional probability distributions associated with each node in the network. These trees show how each node’s probability depends on its parent nodes’ states, providing a visual and computational tool for working with the network’s probabilistic relationships <span class="citation" data-cites="pearl1986fusion">[@pearl1986fusion]</span>.</p>
<p>Understanding these components, nodes, edges, the directed acyclic graph, probabilistic inferences, conditional independence, and the conditional probability tree provides a foundational framework for working with Bayesian networks, enabling the modeling of complex systems with interdependent variables in a structured and efficient manner.</p>
</section>
<section id="i-6.-limitations-of-bayesian-networks" class="level3">
<h3 class="anchored" data-anchor-id="i-6.-limitations-of-bayesian-networks">I-6. Limitations of Bayesian Networks</h3>
<p>Although Bayesian networks are valuable in modeling and predicting probabilistic relationships, they have their limitations that can hinder effectiveness.</p>
<p><strong>Complexity</strong>: One issue is their complexity, which increases with the number of variables introduced. Complexity makes Bayesian Networks computationally intensive to build and maintain for large, highly connected networks, making real-time inference and updates challenging. Data Requirements: Bayesian networks are largely data-driven; thus, the data requirements make sparse data sets potentially compromise reliability.</p>
<p><strong>Assumptions</strong>: Bayesian networks mainly involve assumptions in defining relationships between variables and often use expert inputs, thus being open to subjectivity and biases <span class="citation" data-cites="kubsch2021beyond">[@kubsch2021beyond]</span>. Bayesian models assume that variables are conditionally independent given their parents in the network. In this case, violations of these assumptions affect the correctness of the predictions made with these models.</p>
<p><strong>Structure:</strong> The structure is another critical limitation. Developing a Bayesian network structure does not automatically adapt to new data or changes in the problem domain.</p>
<p><strong>Scalability</strong>: Scalability is a significant limitation: Large networks require substantial computational effort for exact inference and typically rely on approximations, resulting in lower accuracy, noting this significant limitation <span class="citation" data-cites="jewell2009bayesian">[@jewell2009bayesian]</span>. Bayesian networks are also limited in that they cannot model complex relationships and nonlinearity between variables; it makes them less successful in modeling real-world complex interactions compared to other approaches, say, neural networks. These limitations stress that careful application and possible use of hybrid methodologies may be necessary when solving complex problems with Bayesian networks.</p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>